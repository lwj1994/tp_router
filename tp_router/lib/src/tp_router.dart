import 'package:flutter/widgets.dart';
import 'package:flutter/scheduler.dart';
import 'package:go_router/go_router.dart';
import 'package:tp_router_annotation/tp_router_annotation.dart';
import 'navigator_key_registry.dart';
import 'navi_key.dart';
import 'route.dart';
import 'route_observer.dart';
import 'tp_route_info.dart';
import 'page_factory.dart';

/// Main router class that wraps go_router with tp_router routes.
///
/// This class provides a simple interface to configure and use
/// the router with automatically generated routes.
class TpRouter {
  /// The underlying go_router instance.
  final GoRouter _goRouter;

  /// The list of registered routes.
  final List<TpRouteBase> _routes;

  /// The route observer for tracking navigation stack.
  final TpRouteObserver _observer;

  static TpRouter? _instance;

  /// Get the global router instance.
  ///
  /// This is available after the first call to the factory constructor.
  static TpRouter get instance {
    if (_instance == null) {
      throw FlutterError(
        'TpRouter has not been initialized. '
        'Ensure you create a TpRouter instance before accessing it.',
      );
    }
    return _instance!;
  }

  /// Check if TpRouter has been initialized.
  static bool get isInitialized => _instance != null;

  /// Creates a [TpRouter] from a list of [TpRouteBase].
  ///
  /// [routes] should be generated by build_runner or manually assembled.
  ///
  /// [errorBuilder] A custom error page builder.
  ///
  /// [redirect] A global redirection function. This is called for every navigation.
  /// Return a path string to redirect, or null to continue.
  ///
  /// [refreshListenable] A [Listenable] that triggers a refresh of the router
  /// (e.g. for authentication state changes).
  ///
  /// [redirectLimit] The maximum number of redirects allowed during a single
  /// navigation. Defaults to 5.
  ///
  /// [routerNeglect] Whether to ignore the browser history tracking.
  /// Defaults to false.
  ///
  /// [initialLocation] The initial location of the router. If not provided,
  /// it usually defaults to auto-detected initial route or `/`.
  ///
  /// [overridePlatformDefaultLocation] Whether to override the platform default
  /// initial location. Defaults to false.
  ///
  /// [initialExtra] The extra data to pass to the initial location.
  ///
  /// [observers] A list of [NavigatorObserver]s to monitor navigation events.
  /// Note: [TpRouteObserver] is automatically added for stack manipulation support.
  ///
  /// [debugLogDiagnostics] Whether to log diagnostic info to the console.
  /// Defaults to false.
  ///
  /// [navigatorKey] A global key for the root navigator.
  ///
  /// [restorationScopeId] An identifier for state restoration.
  ///
  /// [requestFocus] Whether the router should request focus associated with
  /// the current route. Defaults to true.
  ///
  /// [defaultTransition] Global default page transition builder.
  /// Used when a route does not specify its own transition.
  ///
  /// [defaultTransitionDuration] Global default transition duration.
  ///
  /// [defaultReverseTransitionDuration] Global default reverse transition duration.
  factory TpRouter({
    required List<TpRouteBase> routes,
    Widget Function(BuildContext, TpRouteData)? errorBuilder,
    TpRouteData? Function(BuildContext context, TpRouteData state)? redirect,
    Listenable? refreshListenable,
    int redirectLimit = 5,
    bool routerNeglect = false,
    String? initialLocation,
    bool overridePlatformDefaultLocation = false,
    Object? initialExtra,
    TpRouterConfig? config,
    List<NavigatorObserver>? observers,
    bool debugLogDiagnostics = false,
    GlobalKey<NavigatorState>? navigatorKey,
    String? restorationScopeId,
    bool requestFocus = true,
    TpTransitionsBuilder? defaultTransition,
    Duration? defaultTransitionDuration,
    Duration? defaultReverseTransitionDuration,
    TpPageType? defaultPageType,
    TpPageFactory? defaultPageBuilder,
  }) {
    // Use the provided key or fall back to the global root key
    if (navigatorKey != null) {
      TpNavigatorKeyRegistry.rootKey = navigatorKey;
    }
    final effectiveNavigatorKey = TpNavigatorKeyRegistry.rootKey;

    // Determine initial location logic
    // If initialLocation is provided by user, use it.
    // Otherwise, try to auto-detect from routes.
    String? startLoc = initialLocation;

    if (startLoc == null) {
      for (final route in routes) {
        final loc = _findInitialPath(route);
        if (loc != null) {
          startLoc = loc;
          break;
        }
      }

      // Default to '/' if no initial route found, or the first route's path if available
      if (startLoc == null && routes.isNotEmpty) {
        final first = routes.first;
        if (first is TpRouteInfo) {
          startLoc = first.path;
        }
      }
      startLoc ??= '/';
    }

    // Convert TpRouteBase to GoRoute/ShellRoute
    final config = TpRouterConfig(
      defaultTransition: defaultTransition,
      defaultTransitionDuration: defaultTransitionDuration,
      defaultReverseTransitionDuration: defaultReverseTransitionDuration,
      defaultPageType: defaultPageType,
      defaultPageBuilder: defaultPageBuilder,
    );

    final goRoutes = routes.map((r) => r.toGoRoute(config: config)).toList();

    // Automatically inject TpRouteObserver for stack manipulation support
    final tpObserver = TpRouteObserver();
    final allObservers = [
      tpObserver,
      ...?observers, // User-provided observers come after
    ];

    final goRouter = GoRouter(
      routes: goRoutes,
      initialLocation: startLoc,
      initialExtra: initialExtra,
      errorBuilder: errorBuilder != null
          ? (context, state) => errorBuilder(context, _StateRouteData(state))
          : null,
      redirect: (context, state) {
        if (redirect != null) {
          final target = redirect(context, _StateRouteData(state));
          return target?.fullPath;
        }
        return null;
      },
      refreshListenable: refreshListenable,
      redirectLimit: redirectLimit,
      routerNeglect: routerNeglect,
      overridePlatformDefaultLocation: overridePlatformDefaultLocation,
      observers: allObservers, // â† Use combined observers with TpRouteObserver
      debugLogDiagnostics: debugLogDiagnostics,
      navigatorKey: effectiveNavigatorKey,
      restorationScopeId: restorationScopeId,
      requestFocus: requestFocus,
    );

    _instance = TpRouter._(goRouter, routes, tpObserver);
    return _instance!;
  }

  static String? _findInitialPath(TpRouteBase route) {
    if (route is TpRouteInfo) {
      if (route.isInitial) return route.path;
      for (final child in route.children) {
        final path = _findInitialPath(child);
        if (path != null) return path;
      }
    } else if (route is TpShellRouteInfo) {
      for (final child in route.routes) {
        final path = _findInitialPath(child);
        if (path != null) return path;
      }
    } else if (route is TpStatefulShellRouteInfo) {
      for (final branch in route.branches) {
        for (final child in branch) {
          final path = _findInitialPath(child);
          if (path != null) return path;
        }
      }
    }
    return null;
  }

  TpRouter._(this._goRouter, this._routes, this._observer);

  /// Get a [TpRouterContext] from the given [BuildContext].
  ///
  /// This is similar to `GoRouter.of(context)` but returns a TpRouter API.
  ///
  /// Example:
  /// ```dart
  /// TpRouter.of(context).tp(HomeRoute());
  /// TpRouter.of(context).pop();
  /// ```
  static TpRouterContext of(BuildContext context) => TpRouterContext(context);

  /// Access the underlying [GoRouter] instance.
  GoRouter get goRouter => _goRouter;

  /// Get the router configuration for MaterialApp.router().
  RouterConfig<Object> get routerConfig => _goRouter;

  /// Get the list of registered routes.
  List<TpRouteBase> get routes => List.unmodifiable(_routes);

  /// Get the route observer for stack manipulation.
  ///
  /// This is used internally by delete() method.
  TpRouteObserver get routeObserver => _observer;

  /// Navigate to a route.
  ///
  /// This is the unified navigation method for all routing operations.
  ///
  /// - [route]: The route to navigate to. Use generated route classes or
  ///   [TpRouteData.fromPath] for dynamic paths.
  /// - [isReplace]: If true, replaces the current route instead of pushing.
  /// - [isClearHistory]: If true, clears the navigation stack (like `go`).
  ///
  /// **Note**: You cannot pass both [context] and [navigatorKey] at the same
  /// time. Use [context] for context-aware navigation within the current
  /// navigator, or use [navigatorKey] for navigating within a specific
  /// named navigator.
  ///
  /// Example:
  /// ```dart
  /// // Push a new route
  /// router.tp(HomeRoute());
  ///
  /// // Replace current route
  /// router.tp(SettingsRoute(), isReplace: true);
  ///
  /// // Clear history and go to route
  /// router.tp(LoginRoute(), isClearHistory: true);
  ///
  /// // Using path directly
  /// router.tp(TpRouteData.fromPath('/user/123'));
  /// ```
  Future<T?> tp<T extends Object?>(
    TpRouteData route, {
    BuildContext? context,
    TpNavKey? navigatorKey,
    bool isReplace = false,
    bool isClearHistory = false,
  }) {
    assert(
      !(context != null && navigatorKey != null),
      'Cannot pass both context and navigatorKey. '
      'Use context for context-aware navigation, or navigatorKey for '
      'targeting a specific navigator.',
    );
    // Determine which GoRouter instance to use
    final targetRouter =
        _getTargetRouter(context: context, navigatorKey: navigatorKey);

    if (isClearHistory) {
      targetRouter.go(route.fullPath, extra: route.extra);
      return Future.value(null);
    } else if (isReplace) {
      return targetRouter.pushReplacement<T>(route.fullPath,
          extra: route.extra);
    } else {
      return targetRouter.push<T>(route.fullPath, extra: route.extra);
    }
  }

  /// Helper to resolve the target GoRouter based on context or navigatorKey.
  GoRouter _getTargetRouter({BuildContext? context, TpNavKey? navigatorKey}) {
    assert(
      !(context != null && navigatorKey != null),
      'Cannot pass both context and navigatorKey. '
      'Use context for context-aware navigation, or navigatorKey for '
      'targeting a specific navigator.',
    );
    if (context != null) {
      try {
        return GoRouter.of(context);
      } catch (_) {}
    } else if (navigatorKey != null) {
      final key = navigatorKey.globalKey;
      final ctx = key.currentContext;
      if (ctx != null) {
        try {
          return GoRouter.of(ctx);
        } catch (_) {}
      }
    }
    return _goRouter;
  }

  /// Pop the current route from the navigation stack.
  void pop<T extends Object?>({
    BuildContext? context,
    TpNavKey? navigatorKey,
    T? result,
  }) {
    _getTargetRouter(context: context, navigatorKey: navigatorKey).pop(result);
  }

  /// Check if can pop the current route.
  bool canPop({BuildContext? context, TpNavKey? navigatorKey}) =>
      _getTargetRouter(context: context, navigatorKey: navigatorKey).canPop();

  /// Get the current location.
  String location({BuildContext? context, TpNavKey? navigatorKey}) =>
      _getTargetRouter(context: context, navigatorKey: navigatorKey)
          .routerDelegate
          .currentConfiguration
          .fullPath;

  /// Pop routes until the predicate is satisfied.
  ///
  /// The [predicate] callback is called for each route on the stack (from top to bottom).
  /// [data] will be provided if the route is a Tp-managed route, otherwise it will be null.
  void popUntil(
    bool Function(Route<dynamic> route, TpRouteData? data) predicate, {
    BuildContext? context,
    TpNavKey? navigatorKey,
  }) {
    final nav = _getNavigator(context: context, navigatorKey: navigatorKey);
    final observer = _findObserverInNavigator(nav);
    nav.popUntil((route) {
      final data = observer?.getRouteData(route);
      return predicate(route, data);
    });
  }

  /// Pop until the first route in the stack.
  void popToInitial({
    BuildContext? context,
    TpNavKey? navigatorKey,
  }) {
    popUntil((route, _) => route.isFirst,
        context: context, navigatorKey: navigatorKey);
  }

  /// Pop until the specified route is found.
  ///
  /// Matches by [TpRouteData.routeName] and [TpRouteData.fullPath].
  void popTo(
    TpRouteData route, {
    BuildContext? context,
    TpNavKey? navigatorKey,
  }) {
    popUntil((r, data) => data == route,
        context: context, navigatorKey: navigatorKey);
  }

  /// Remove a route from the navigation stack.
  bool removeRoute(
    TpRouteData route, {
    BuildContext? context,
    TpNavKey? navigatorKey,
  }) {
    return removeWhere(
          (data) =>
              data.routeName == route.routeName &&
              data.fullPath == route.fullPath,
          context: context,
          navigatorKey: navigatorKey,
        ) >
        0;
  }

  /// Remove all routes that match the given predicate.
  int removeWhere(
    bool Function(TpRouteData data) predicate, {
    BuildContext? context,
    TpNavKey? navigatorKey,
  }) {
    final navigator = _getNavigator(
      context: context,
      navigatorKey: navigatorKey,
    );

    final observer = _findObserverInNavigator(navigator);
    if (observer == null) return 0;

    final routesToRemove = <Route>[];
    for (final route in observer.allRoutes) {
      final data = observer.getRouteData(route);
      if (data != null && predicate(data)) {
        routesToRemove.add(route);
      }
    }

    SchedulerBinding.instance.addPostFrameCallback((_) {
      for (final route in routesToRemove) {
        if (route.isCurrent) {
          navigator.pop();
        } else {
          observer.markRouteForRemoval(route);
        }
      }
    });

    return routesToRemove.length;
  }

  /// Get the route observer for tracking navigation stack.
  TpRouteObserver? getObserver({
    BuildContext? context,
    TpNavKey? navigatorKey,
  }) {
    final navigator = _getNavigator(
      context: context,
      navigatorKey: navigatorKey,
    );
    return _findObserverInNavigator(navigator);
  }

  /// Internal helper to get NavigatorState.
  ///
  /// Logic:
  /// 1. If navigatorKey is provided and found, use it.
  /// 2. Else if context is provided, use Navigator.of(context).
  /// 3. Otherwise (navigatorKey null/not found AND context null), use root.
  NavigatorState _getNavigator({
    BuildContext? context,
    TpNavKey? navigatorKey,
  }) {
    assert(
      !(context != null && navigatorKey != null),
      'Cannot pass both context and navigatorKey. '
      'Use context for context-aware navigation, or navigatorKey for '
      'targeting a specific navigator.',
    );
    // Try navigatorKey first
    if (navigatorKey != null) {
      final key = navigatorKey.globalKey;
      if (key.currentState != null) return key.currentState!;
    }

    // Then try context
    if (context != null) return Navigator.of(context);

    // Fallback to root (navigatorKey null/not found AND context null)
    return TpNavigatorKeyRegistry.rootKey.currentState!;
  }

  TpRouteObserver? _findObserverInNavigator(NavigatorState navigator) {
    return _searchObservers(navigator.widget.observers);
  }

  TpRouteObserver? _searchObservers(List<NavigatorObserver> observers) {
    for (final observer in observers) {
      if (observer is TpRouteObserver) return observer;
      try {
        final dynamic dynamicObserver = observer;
        final children = dynamicObserver.observers;
        if (children is List<NavigatorObserver>) {
          final found = _searchObservers(children);
          if (found != null) return found;
        }
      } catch (_) {}
    }
    return null;
  }

  /// Dispose the router.
  void dispose() {
    _goRouter.dispose();
  }
}

/// Context-bound router accessor for navigation.
///
/// This provides a convenient API: `context.tpRouter.tp(route)`.
class TpRouterContext {
  final BuildContext _context;

  /// Creates a [TpRouterContext] bound to the given [context].
  TpRouterContext(this._context);

  /// Navigate to a route.
  ///
  /// This is the unified navigation method for all routing operations.
  ///
  /// - [route]: The route to navigate to. Use generated route classes or
  ///   [TpRouteData.fromPath] for dynamic paths.
  /// - [isReplace]: If true, replaces the current route instead of pushing.
  /// - [isClearHistory]: If true, clears the navigation stack (like `go`).
  ///
  /// Example:
  /// ```dart
  /// // Push a new route
  /// context.tpRouter.tp(HomeRoute());
  ///
  /// // Replace current route
  /// context.tpRouter.tp(SettingsRoute(), isReplace: true);
  ///
  /// // Clear history and go to route
  /// context.tpRouter.tp(LoginRoute(), isClearHistory: true);
  ///
  /// // Using path directly
  /// context.tpRouter.tp(TpRouteData.fromPath('/user/123'));
  /// ```
  Future<T?> tp<T extends Object?>(
    TpRouteData route, {
    bool isReplace = false,
    bool isClearHistory = false,
  }) {
    return TpRouter.instance.tp<T>(
      route,
      context: _context,
      isReplace: isReplace,
      isClearHistory: isClearHistory,
    );
  }

  /// Pop the current route from the navigation stack.
  void pop<T extends Object?>([T? result]) {
    TpRouter.instance.pop<T>(context: _context, result: result);
  }

  /// Pop routes until the predicate is satisfied.
  void popUntil(
      bool Function(Route<dynamic> route, TpRouteData? data) predicate) {
    TpRouter.instance.popUntil(predicate, context: _context);
  }

  /// Pop until the first route in the stack.
  void popToInitial() {
    TpRouter.instance.popToInitial(context: _context);
  }

  /// Pop until the specified route is found.
  void popTo(TpRouteData route) {
    TpRouter.instance.popTo(route, context: _context);
  }

  /// Check if can pop the current route.
  bool get canPop => TpRouter.instance.canPop(context: _context);

  /// Get the current location.
  String get currentFullPath => TpRouter.instance.location(context: _context);

  /// Remove a route from the navigation stack.
  bool removeRoute(
    TpRouteData route, {
    TpNavKey? navigatorKey,
  }) {
    return TpRouter.instance.removeRoute(
      route,
      context: _context,
      navigatorKey: navigatorKey,
    );
  }

  /// Remove all routes that match the given predicate.
  int removeWhere(
    bool Function(TpRouteData data) predicate, {
    TpNavKey? navigatorKey,
  }) {
    return TpRouter.instance.removeWhere(
      predicate,
      context: _context,
      navigatorKey: navigatorKey,
    );
  }

  /// Get the route observer for tracking navigation stack.
  TpRouteObserver? getObserver({
    TpNavKey? navigatorKey,
  }) {
    return TpRouter.instance.getObserver(
      context: _context,
      navigatorKey: navigatorKey,
    );
  }
}

/// Extension on [BuildContext] for easy access to TpRouter.
///
/// Usage:
/// ```dart
/// context.tpRouter.tp(HomeRoute());
/// context.tpRouter.tp(TpRouteData.fromPath('/details'));
/// context.tpRouter.pop();
/// ```
extension TpRouterExtension on BuildContext {
  /// Access the TpRouter API from this context.
  ///
  /// Example:
  /// ```dart
  /// context.tpRouter.tp(UserRoute(id: 123));
  /// context.tpRouter.pop();
  /// ```
  TpRouterContext get tpRouter => TpRouterContext(this);
}

/// Internal implementation of TpRouteData that wraps GoRouterState.
class _StateRouteData extends TpRouteData {
  final GoRouterState _state;

  const _StateRouteData(this._state);

  @override
  String? get routeName => _state.name;

  @override
  String get fullPath => _state.uri.toString();

  @override
  Uri get uri => _state.uri;

  @override
  Map<String, String> get pathParams => _state.pathParameters;

  @override
  Map<String, String> get queryParams => _state.uri.queryParameters;

  @override
  Map<String, dynamic> get extra {
    final e = _state.extra;
    if (e is Map<String, dynamic>) {
      return e;
    }
    return const {};
  }

  @override
  Object? get error => _state.error;
}
