import 'package:flutter/widgets.dart';
import 'package:go_router/go_router.dart';
import 'package:tp_router_annotation/tp_router_annotation.dart';
import 'route.dart';
import 'route_observer.dart';
import 'tp_route_info.dart';

/// Main router class that wraps go_router with tp_router routes.
///
/// This class provides a simple interface to configure and use
/// the router with automatically generated routes.
class TpRouter {
  /// The underlying go_router instance.
  final GoRouter _goRouter;

  /// The list of registered routes.
  final List<TpRouteBase> _routes;

  /// The route observer for tracking navigation stack.
  final TpRouteObserver _observer;

  /// Creates a [TpRouter] from a list of [TpRouteBase].
  ///
  /// [routes] should be generated by build_runner or manually assembled.
  ///
  /// [errorBuilder] A custom error page builder.
  ///
  /// [redirect] A global redirection function. This is called for every navigation.
  /// Return a path string to redirect, or null to continue.
  ///
  /// [refreshListenable] A [Listenable] that triggers a refresh of the router
  /// (e.g. for authentication state changes).
  ///
  /// [redirectLimit] The maximum number of redirects allowed during a single
  /// navigation. Defaults to 5.
  ///
  /// [routerNeglect] Whether to ignore the browser history tracking.
  /// Defaults to false.
  ///
  /// [initialLocation] The initial location of the router. If not provided,
  /// it usually defaults to auto-detected initial route or `/`.
  ///
  /// [overridePlatformDefaultLocation] Whether to override the platform default
  /// initial location. Defaults to false.
  ///
  /// [initialExtra] The extra data to pass to the initial location.
  ///
  /// [observers] A list of [NavigatorObserver]s to monitor navigation events.
  /// Note: [TpRouteObserver] is automatically added for stack manipulation support.
  ///
  /// [debugLogDiagnostics] Whether to log diagnostic info to the console.
  /// Defaults to false.
  ///
  /// [navigatorKey] A global key for the root navigator.
  ///
  /// [restorationScopeId] An identifier for state restoration.
  ///
  /// [requestFocus] Whether the router should request focus associated with
  /// the current route. Defaults to true.
  ///
  /// [defaultTransition] Global default page transition builder.
  /// Used when a route does not specify its own transition.
  ///
  /// [defaultTransitionDuration] Global default transition duration.
  ///
  /// [defaultReverseTransitionDuration] Global default reverse transition duration.
  factory TpRouter({
    required List<TpRouteBase> routes,
    Widget Function(BuildContext, TpRouteData)? errorBuilder,
    TpRouteData? Function(BuildContext context, TpRouteData state)? redirect,
    Listenable? refreshListenable,
    int redirectLimit = 5,
    bool routerNeglect = false,
    String? initialLocation,
    bool overridePlatformDefaultLocation = false,
    Object? initialExtra,
    TpRouterConfig? config,
    List<NavigatorObserver>? observers,
    bool debugLogDiagnostics = false,
    GlobalKey<NavigatorState>? navigatorKey,
    String? restorationScopeId,
    bool requestFocus = true,
    TpTransitionsBuilder? defaultTransition,
    Duration? defaultTransitionDuration,
    Duration? defaultReverseTransitionDuration,
  }) {
    // Determine initial location logic
    // If initialLocation is provided by user, use it.
    // Otherwise, try to auto-detect from routes.
    String? startLoc = initialLocation;

    if (startLoc == null) {
      for (final route in routes) {
        final loc = _findInitialPath(route);
        if (loc != null) {
          startLoc = loc;
          break;
        }
      }

      // Default to '/' if no initial route found, or the first route's path if available
      if (startLoc == null && routes.isNotEmpty) {
        final first = routes.first;
        if (first is TpRouteInfo) {
          startLoc = first.path;
        }
      }
      startLoc ??= '/';
    }

    // Convert TpRouteBase to GoRoute/ShellRoute
    final config = TpRouterConfig(
      defaultTransition: defaultTransition,
      defaultTransitionDuration: defaultTransitionDuration,
      defaultReverseTransitionDuration: defaultReverseTransitionDuration,
    );

    final goRoutes = routes.map((r) => r.toGoRoute(config: config)).toList();

    // Automatically inject TpRouteObserver for stack manipulation support
    final tpObserver = TpRouteObserver();
    final allObservers = [
      tpObserver,
      ...?observers, // User-provided observers come after
    ];

    final goRouter = GoRouter(
      routes: goRoutes,
      initialLocation: startLoc,
      initialExtra: initialExtra,
      errorBuilder: errorBuilder != null
          ? (context, state) => errorBuilder(context, _StateRouteData(state))
          : null,
      redirect: (context, state) {
        if (redirect != null) {
          final target = redirect(context, _StateRouteData(state));
          return target?.fullPath;
        }
        return null;
      },
      refreshListenable: refreshListenable,
      redirectLimit: redirectLimit,
      routerNeglect: routerNeglect,
      overridePlatformDefaultLocation: overridePlatformDefaultLocation,
      observers: allObservers, // â† Use combined observers with TpRouteObserver
      debugLogDiagnostics: debugLogDiagnostics,
      navigatorKey: navigatorKey,
      restorationScopeId: restorationScopeId,
      requestFocus: requestFocus,
    );

    return TpRouter._(goRouter, routes, tpObserver);
  }

  static String? _findInitialPath(TpRouteBase route) {
    if (route is TpRouteInfo) {
      if (route.isInitial) return route.path;
      for (final child in route.children) {
        final path = _findInitialPath(child);
        if (path != null) return path;
      }
    } else if (route is TpShellRouteInfo) {
      for (final child in route.routes) {
        final path = _findInitialPath(child);
        if (path != null) return path;
      }
    } else if (route is TpStatefulShellRouteInfo) {
      for (final branch in route.branches) {
        for (final child in branch) {
          final path = _findInitialPath(child);
          if (path != null) return path;
        }
      }
    }
    return null;
  }

  TpRouter._(this._goRouter, this._routes, this._observer);

  /// Get a [TpRouterContext] from the given [BuildContext].
  ///
  /// This is similar to `GoRouter.of(context)` but returns a TpRouter API.
  ///
  /// Example:
  /// ```dart
  /// TpRouter.of(context).tp(HomeRoute());
  /// TpRouter.of(context).pop();
  /// ```
  static TpRouterContext of(BuildContext context) => TpRouterContext(context);

  /// Access the underlying [GoRouter] instance.
  GoRouter get goRouter => _goRouter;

  /// Get the router configuration for MaterialApp.router().
  RouterConfig<Object> get routerConfig => _goRouter;

  /// Get the list of registered routes.
  List<TpRouteBase> get routes => List.unmodifiable(_routes);

  /// Get the route observer for stack manipulation.
  ///
  /// This is used internally by delete() method.
  TpRouteObserver get routeObserver => _observer;

  /// Navigate to a route.
  ///
  /// This is the unified navigation method for all routing operations.
  ///
  /// - [route]: The route to navigate to. Use generated route classes or
  ///   [TpRouteData.fromPath] for dynamic paths.
  /// - [isReplace]: If true, replaces the current route instead of pushing.
  /// - [isClearHistory]: If true, clears the navigation stack (like `go`).
  ///
  /// Example:
  /// ```dart
  /// // Push a new route
  /// router.tp(HomeRoute());
  ///
  /// // Replace current route
  /// router.tp(SettingsRoute(), isReplace: true);
  ///
  /// // Clear history and go to route
  /// router.tp(LoginRoute(), isClearHistory: true);
  ///
  /// // Using path directly
  /// router.tp(TpRouteData.fromPath('/user/123'));
  /// ```
  Future<T?> tp<T extends Object?>(
    TpRouteData route, {
    bool isReplace = false,
    bool isClearHistory = false,
  }) {
    if (isClearHistory) {
      _goRouter.go(route.fullPath, extra: route.extra);
      return Future.value(null);
    } else if (isReplace) {
      return _goRouter.pushReplacement<T>(route.fullPath, extra: route.extra);
    } else {
      return _goRouter.push<T>(route.fullPath, extra: route.extra);
    }
  }

  /// Pop the current route from the navigation stack.
  void pop<T extends Object?>([T? result]) {
    _goRouter.pop(result);
  }

  /// Check if can pop the current route.
  bool canPop() => _goRouter.canPop();

  /// Get the current location.
  String get location => _goRouter.routerDelegate.currentConfiguration.fullPath;

  /// Dispose the router.
  void dispose() {
    _goRouter.dispose();
  }
}

/// Context-bound router accessor for navigation.
///
/// This provides a convenient API: `context.tpRouter.tp(route)`.
class TpRouterContext {
  final BuildContext _context;

  /// Creates a [TpRouterContext] bound to the given [context].
  TpRouterContext(this._context);

  GoRouter get _goRouter => GoRouter.of(_context);

  /// Navigate to a route.
  ///
  /// This is the unified navigation method for all routing operations.
  ///
  /// - [route]: The route to navigate to. Use generated route classes or
  ///   [TpRouteData.fromPath] for dynamic paths.
  /// - [isReplace]: If true, replaces the current route instead of pushing.
  /// - [isClearHistory]: If true, clears the navigation stack (like `go`).
  ///
  /// Example:
  /// ```dart
  /// // Push a new route
  /// context.tpRouter.tp(HomeRoute());
  ///
  /// // Replace current route
  /// context.tpRouter.tp(SettingsRoute(), isReplace: true);
  ///
  /// // Clear history and go to route
  /// context.tpRouter.tp(LoginRoute(), isClearHistory: true);
  ///
  /// // Using path directly
  /// context.tpRouter.tp(TpRouteData.fromPath('/user/123'));
  /// ```
  Future<T?> tp<T extends Object?>(
    TpRouteData route, {
    bool isReplace = false,
    bool isClearHistory = false,
  }) {
    if (isClearHistory) {
      _goRouter.go(route.fullPath, extra: route.extra);
      return Future.value(null);
    } else if (isReplace) {
      return _goRouter.pushReplacement<T>(route.fullPath, extra: route.extra);
    } else {
      return _goRouter.push<T>(route.fullPath, extra: route.extra);
    }
  }

  /// Pop the current route from the navigation stack.
  void pop<T extends Object?>([T? result]) {
    if (!canPop) return;
    _goRouter.pop(result);
  }

  /// Pop routes until the predicate is satisfied.
  void popUntil(bool Function(Route<dynamic>) predicate) {
    if (canPop) {
      Navigator.of(_context, rootNavigator: false).popUntil(predicate);
    }
  }

  /// Check if can pop the current route.
  bool get canPop => _goRouter.canPop();

  /// Get the current location.
  String get currentFullPath =>
      _goRouter.routerDelegate.currentConfiguration.fullPath;

  /// Get navigator key by name.
  ///
  /// This is used internally by delete() method to access specific navigators.
  /// Returns null if the navigator key is not registered.
  GlobalKey<NavigatorState>? getNavigatorKey(String key) {
    // Navigator keys are stored in GoRouter's configuration
    // For now, we return null and fall back to current navigator
    // TODO: Implement navigator key registry if needed
    return null;
  }

  /// Remove a route from the navigation stack.
  ///
  /// Returns `true` if a matching route was found and removed, `false` otherwise.
  ///
  /// **Note**: This requires TpRouter to be initialized with TpRouteObserver.
  /// The observer is added automatically when using TpRouter.
  ///
  /// Use [navigatorKey] to target a specific Navigator (e.g., shell route navigator).
  /// Use [rootNavigator] to target the root Navigator.
  ///
  /// Example:
  /// ```dart
  /// // Remove from current Navigator
  /// context.tpRouter.removeRoute(LoginRoute());
  ///
  /// // Remove from specific Navigator (shell route)
  /// context.tpRouter.removeRoute(ProfileRoute(), navigatorKey: 'main');
  ///
  /// // Remove from root Navigator
  /// context.tpRouter.removeRoute(DialogRoute(), rootNavigator: true);
  /// ```
  bool removeRoute(
    TpRouteData route, {
    String? navigatorKey,
    bool rootNavigator = false,
  }) {
    // Use removeWhere to remove routes matching both routeName and fullPath
    final removed = removeWhere(
      (data) =>
          data.routeName == route.routeName && data.fullPath == route.fullPath,
      navigatorKey: navigatorKey,
      rootNavigator: rootNavigator,
    );
    return removed > 0;
  }

  /// Remove all routes that match the given predicate.
  ///
  /// Returns the number of routes removed.
  ///
  /// **Note**: This requires TpRouter to be initialized with TpRouteObserver.
  ///
  /// The predicate function receives a [TpRouteData] object and should return `true`
  /// to remove the route, `false` to keep it.
  ///
  /// Use [navigatorKey] to target a specific Navigator.
  /// Use [rootNavigator] to target the root Navigator.
  ///
  /// Example:
  /// ```dart
  /// // Remove all routes with specific parameter
  /// final count = context.tpRouter.removeWhere(
  ///   (data) => data.pathParams['id'] == '123',
  /// );
  ///
  /// // Remove all routes matching a path pattern
  /// context.tpRouter.removeWhere(
  ///   (data) => data.fullPath.contains('dialog'),
  /// );
  /// ```
  int removeWhere(
    bool Function(TpRouteData data) predicate, {
    String? navigatorKey,
    bool rootNavigator = false,
  }) {
    final navigator = _getNavigator(navigatorKey, rootNavigator);
    final observer = getObserver(navigatorKey, rootNavigator);

    if (observer == null) {
      return 0;
    }

    // Get all tracked routes, extract their data, and filter by predicate
    final routesToRemove = <Route>[];
    for (final route in observer.allRoutes) {
      final data = observer.getRouteData(route);
      if (data != null && predicate(data)) {
        routesToRemove.add(route);
      }
    }

    for (final route in routesToRemove) {
      navigator.removeRoute(route);
    }

    return routesToRemove.length;
  }

  /// Get the Navigator instance based on provided parameters.
  NavigatorState _getNavigator(
    String? navigatorKey,
    bool rootNavigator,
  ) {
    if (rootNavigator) {
      return Navigator.of(_context, rootNavigator: true);
    }

    if (navigatorKey != null) {
      final key = getNavigatorKey(navigatorKey);
      if (key?.currentState != null) {
        return key!.currentState!;
      }
      // Fallback to current navigator if key not found
      return Navigator.of(_context);
    }

    return Navigator.of(_context);
  }

  /// Get the route observer for tracking navigation stack.
  ///
  /// This is used internally by delete() method.
  TpRouteObserver? getObserver(String? navigatorKey, bool rootNavigator) {
    // Get the observer from TpRouter instance (automatically injected)
    final goRouter = GoRouter.of(_context);

    // Find TpRouter instance through GoRouter's observers
    for (final observer in goRouter
            .routerDelegate.navigatorKey.currentState?.widget.observers ??
        <NavigatorObserver>[]) {
      if (observer is TpRouteObserver) {
        return observer;
      }
    }

    return null;
  }
}

/// Extension on [BuildContext] for easy access to TpRouter.
///
/// Usage:
/// ```dart
/// context.tpRouter.tp(HomeRoute());
/// context.tpRouter.tp(TpRouteData.fromPath('/details'));
/// context.tpRouter.pop();
/// ```
extension TpRouterExtension on BuildContext {
  /// Access the TpRouter API from this context.
  ///
  /// Example:
  /// ```dart
  /// context.tpRouter.tp(UserRoute(id: 123));
  /// context.tpRouter.pop();
  /// ```
  TpRouterContext get tpRouter => TpRouterContext(this);
}

/// Internal implementation of TpRouteData that wraps GoRouterState.
class _StateRouteData extends TpRouteData {
  final GoRouterState _state;

  const _StateRouteData(this._state);

  @override
  String get routeName => _state.name ?? _state.matchedLocation;

  @override
  String get fullPath => _state.uri.toString();

  @override
  Uri get uri => _state.uri;

  @override
  Map<String, String> get pathParams => _state.pathParameters;

  @override
  Map<String, String> get queryParams => _state.uri.queryParameters;

  @override
  Map<String, dynamic> get extra {
    final e = _state.extra;
    if (e is Map<String, dynamic>) {
      return e;
    }
    return const {};
  }

  @override
  Object? get error => _state.error;
}
