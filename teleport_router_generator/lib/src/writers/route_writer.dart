import '../models/route_data.dart';

class RouteWriter {
  static const _kRoutePrefix = 'teleport_router_';

  /// Generates the complete output file content.
  String generateFile(List<BaseRouteData> allRoutes, Set<String> imports) {
    // Build a map of navigatorKey -> basePath for resolving relative paths
    final shellBasePaths = <String, String>{};
    for (final route in allRoutes) {
      if (route is ShellRouteData) {
        // If basePath is not specified, default to '/' for shells with children
        shellBasePaths[route.navigatorKey] = route.basePath ?? '/';
      }
    }

    // Resolve relative paths in routes
    final resolvedRoutes = <BaseRouteData>[];
    for (final route in allRoutes) {
      if (route is RouteData) {
        String resolvedPath = route.path;
        if (!route.path.startsWith('/') && route.parentNavigatorKey != null) {
          final basePath = shellBasePaths[route.parentNavigatorKey];
          if (basePath != null) {
            // Ensure basePath ends with / and path doesn't start with /
            final cleanBasePath = basePath.endsWith('/')
                ? basePath.substring(0, basePath.length - 1)
                : basePath;
            resolvedPath = '$cleanBasePath/${route.path}';
          }
        }
        // Create new RouteData with resolved path
        resolvedRoutes.add(RouteData(
          className: route.className,
          routeClassName: route.routeClassName,
          path: resolvedPath,
          originalPath: route.originalPath,
          isInitial: route.isInitial,
          params: route.params,
          redirect: route.redirect,
          transitionType: route.transitionType,
          transitionDuration: route.transitionDuration,
          reverseTransitionDuration: route.reverseTransitionDuration,
          parentNavigatorKey: route.parentNavigatorKey,
          onExit: route.onExit,
          fullscreenDialog: route.fullscreenDialog,
          opaque: route.opaque,
          barrierDismissible: route.barrierDismissible,
          barrierColor: route.barrierColor,
          barrierLabel: route.barrierLabel,
          maintainState: route.maintainState,
          pageBuilder: route.pageBuilder,
          extraImports: route.extraImports,
          pageType: route.pageType,
        ));
      } else {
        resolvedRoutes.add(route);
      }
    }

    final buffer = StringBuffer();

    // Header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by teleport_router_generator');
    buffer.writeln();
    buffer.writeln("import 'package:teleport_router/teleport_router.dart';");

    // Import source files
    for (final import in imports.toList()..sort()) {
      buffer.writeln("import '$import';");
    }
    buffer.writeln();

    // Generate Route classes (use resolved routes)
    for (final route in resolvedRoutes) {
      if (route is RouteData) {
        buffer.writeln(generateRouteClass(route, resolvedRoutes));
      } else if (route is ShellRouteData) {
        buffer.writeln(generateShellRouteClass(route, resolvedRoutes));
      }
    }

    // Generate teleportRoutes list (Tree Structure)
    buffer.writeln('/// All generated routes in the application.');
    buffer.writeln('///');
    buffer.writeln('/// Use this list to initialize [TeleportRouter]:');
    buffer.writeln('/// ```dart');
    buffer
        .writeln('/// final router = TeleportRouter(routes: teleportRoutes);');
    buffer.writeln('/// ```');
    buffer.writeln('List<TeleportRouteBase> get teleportRoutes => [');

    // Find child routes (routes with navigatorKey) to exclude from root list
    final childRouteClassNames = <String>{};
    for (final route in resolvedRoutes) {
      if (route is RouteData && route.parentNavigatorKey != null) {
        childRouteClassNames.add(route.className);
      } else if (route is ShellRouteData && route.parentNavigatorKey != null) {
        childRouteClassNames.add(route.className);
      }
    }

    // Generate root routes (shells and routes without navigatorKey)
    for (final route in resolvedRoutes) {
      if (!childRouteClassNames.contains(route.className)) {
        buffer.writeln('      ${route.routeClassName}.routeInfo,');
      }
    }
    buffer.writeln('    ];');

    return buffer.toString();
  }

  /// Groups child routes by navigatorKey and branchIndex.
  Map<int, List<BaseRouteData>> groupChildRoutesByBranch(
    String navigatorKey,
    List<BaseRouteData> allRoutes, {
    List<String> branchKeys = const [],
  }) {
    final branches = <int, List<BaseRouteData>>{};
    for (final route in allRoutes) {
      if (route is RouteData) {
        if (route.parentNavigatorKey == navigatorKey) {
          branches.putIfAbsent(0, () => []).add(route);
        } else if (route.parentNavigatorKey != null &&
            branchKeys.contains(route.parentNavigatorKey)) {
          final index = branchKeys.indexOf(route.parentNavigatorKey!);
          branches.putIfAbsent(index, () => []).add(route);
        }
      } else if (route is ShellRouteData) {
        if (route.parentNavigatorKey == navigatorKey) {
          branches.putIfAbsent(0, () => []).add(route);
        } else if (route.parentNavigatorKey != null &&
            branchKeys.contains(route.parentNavigatorKey)) {
          final index = branchKeys.indexOf(route.parentNavigatorKey!);
          branches.putIfAbsent(index, () => []).add(route);
        }
      }
    }
    return branches;
  }

  String generateShellRouteClass(
    ShellRouteData route,
    List<BaseRouteData> allRoutes,
  ) {
    final buffer = StringBuffer();
    buffer.writeln('class ${route.routeClassName} {');

    // Generate static navigatorKey constant and GlobalKey
    if (!route.isIndexedStack) {
      buffer.writeln(
        '  static final navigatorGlobalKey = const ${route.navigatorKey}().globalKey;',
      );
      buffer.writeln(
        '  static const navigatorKey = ${route.navigatorKey}();',
      );
    }
    buffer.writeln();

    // Find child routes by navigatorKey
    final branchesMap = groupChildRoutesByBranch(
      route.navigatorKey,
      allRoutes,
      branchKeys: route.branchKeys,
    );
    final sortedBranchIndices = branchesMap.keys.toList()..sort();

    if (route.isIndexedStack) {
      // Generate static navigatorKey instance for reference
      buffer.writeln('  static final navigatorKey = ${route.navigatorKey}();');

      // Generate TeleportNavKey for each branch
      if (route.branchKeys.isEmpty) {
        for (int i = 0; i < sortedBranchIndices.length; i++) {
          // For indexed stacks, we create branch-specific keys using the base key
          buffer.writeln(
            '  static final _branchKey$i = TeleportNavKey.value(navigatorKey.key, branch: $i);',
          );
        }
      }
      buffer.writeln();

      // Generate TeleportStatefulShellRouteInfo
      buffer.writeln(
        '  static final TeleportStatefulShellRouteInfo routeInfo = TeleportStatefulShellRouteInfo(',
      );
      // For stateful shell, the builder receives navigationShell
      buffer.writeln(
        '    builder: (context, navigationShell) => ${route.className}(navigationShell: navigationShell),',
      );
      buffer.writeln('    branches: [');
      for (final branchIndex in sortedBranchIndices) {
        final branchRoutes = branchesMap[branchIndex]!;
        buffer.writeln('      [');
        for (final childRoute in branchRoutes) {
          buffer.writeln('        ${childRoute.routeClassName}.routeInfo,');
        }
        buffer.writeln('      ],');
      }
      buffer.writeln('    ],');
      // Pass branch navigator keys
      buffer.write('    branchNavigatorKeys: [');
      if (route.branchKeys.isNotEmpty) {
        for (final key in route.branchKeys) {
          buffer.write('$key(), ');
        }
      } else {
        for (int i = 0; i < sortedBranchIndices.length; i++) {
          buffer.write('_branchKey$i, ');
        }
      }
      buffer.writeln('],');

      // Generate observersBuilder (TeleportRouteObserver is auto-injected via branchNavigatorKeys)
      if (route.observers.isNotEmpty) {
        buffer.writeln('    observersBuilder: () => [');
        for (final observer in route.observers) {
          buffer.writeln('      $observer(),');
        }
        buffer.writeln('    ],');
      }

      // Generate page config
      if (route.fullscreenDialog) buffer.writeln('    fullscreenDialog: true,');
      if (route.opaque) buffer.writeln('    opaque: true,');
      if (route.barrierDismissible)
        buffer.writeln('    barrierDismissible: true,');
      if (route.barrierColor != null)
        buffer.writeln('    barrierColor: Color(${route.barrierColor}),');
      if (route.barrierLabel != null)
        buffer.writeln("    barrierLabel: '${route.barrierLabel}',");
      if (!route.maintainState) buffer.writeln('    maintainState: false,');

      if (route.pageBuilder != null) {
        buffer.writeln('    pageBuilder: ${route.pageBuilder!.name}(),');
      }

      buffer.writeln('  );');
    } else {
      // Original Stateless ShellRoute
      buffer.writeln(
        '  static final TeleportShellRouteInfo routeInfo = TeleportShellRouteInfo(',
      );
      buffer.writeln(
        '    builder: (context, child) => ${route.className}(child: child),',
      );
      buffer.writeln('    navigatorKey: navigatorGlobalKey,');
      buffer.writeln('    routes: [');
      // For regular shell, all child routes go into a flat list
      for (final branchIndex in sortedBranchIndices) {
        final branchRoutes = branchesMap[branchIndex]!;
        for (final childRoute in branchRoutes) {
          buffer.writeln('      ${childRoute.routeClassName}.routeInfo,');
        }
      }
      buffer.writeln('    ],');
      // Generate observers (TeleportRouteObserver is auto-injected via navigatorKey)
      if (route.observers.isNotEmpty) {
        buffer.writeln('    observers: [');
        for (final observer in route.observers) {
          buffer.writeln('      $observer(),');
        }
        buffer.writeln('    ],');
      }
      // Generate page config
      if (route.fullscreenDialog) buffer.writeln('    fullscreenDialog: true,');
      if (route.opaque) buffer.writeln('    opaque: true,');
      if (route.barrierDismissible)
        buffer.writeln('    barrierDismissible: true,');
      if (route.barrierColor != null)
        buffer.writeln('    barrierColor: Color(${route.barrierColor}),');
      if (route.barrierLabel != null)
        buffer.writeln("    barrierLabel: '${route.barrierLabel}',");
      if (!route.maintainState) buffer.writeln('    maintainState: false,');

      if (route.pageBuilder != null) {
        buffer.writeln('    pageBuilder: ${route.pageBuilder!.name}(),');
      }
      if (route.pageType != null) {
        buffer.writeln('    type: ${route.pageType},');
      }

      buffer.writeln('  );');
    }

    buffer.writeln('}');
    buffer.writeln();
    return buffer.toString();
  }

  /// Generates a Route class for navigation.
  String generateRouteClass(RouteData route, List<BaseRouteData> allRoutes) {
    final buffer = StringBuffer();
    final routeClassName = route.routeClassName;

    buffer.writeln('/// Route class for [${route.className}].');
    buffer.writeln('///');
    buffer.writeln('/// Usage:');
    buffer.writeln('/// ```dart');
    if (route.params.isEmpty) {
      buffer.writeln('/// $routeClassName().teleport();');
    } else {
      final exampleArgs = route.params
          .where((p) => p.isRequired)
          .map((p) => '${p.name}: ${getExampleValue(p)}')
          .join(', ');
      buffer.writeln('/// $routeClassName($exampleArgs).teleport();');
    }
    buffer.writeln('/// ```');
    buffer.writeln('class $routeClassName extends TeleportRouteData {');

    // Fields
    for (final param in route.params) {
      buffer.writeln('  final ${param.type} ${param.name};');
    }
    if (route.params.isNotEmpty) {
      buffer.writeln();
    }

    // Constructor
    buffer.write('  const $routeClassName(');
    if (route.params.isNotEmpty) {
      buffer.writeln('{');
      for (final param in route.params) {
        if (param.isRequired) {
          buffer.writeln('    required this.${param.name},');
        } else {
          if (param.defaultValueCode != null) {
            buffer.writeln(
              '    this.${param.name} = ${param.defaultValueCode},',
            );
          } else {
            buffer.writeln('    this.${param.name},');
          }
        }
      }
      buffer.write('  }');
    }
    buffer.writeln(');');
    buffer.writeln();

    // Route name getter (override from TeleportRouteData)
    buffer.writeln('  @override');
    buffer.writeln(
      "  String get routeName => '$_kRoutePrefix${route.routeClassName}';",
    );
    buffer.writeln();
    buffer.writeln(
        "  static const String kName = '$_kRoutePrefix${route.routeClassName}';");
    buffer.writeln();

    buffer.writeln(
        '  /// Creates a [${route.routeClassName}] from [TeleportRouteData].');
    buffer.writeln(
        '  static ${route.routeClassName} fromData(TeleportRouteData data) {');
    buffer.writeln('    if (data is ${route.routeClassName}) return data;');

    // Only add settings variable if there are parameters to extract
    if (route.params.isNotEmpty) {
      buffer.writeln('    final settings = data;');
      for (final param in route.params) {
        buffer.writeln(generateParamExtraction(param));
      }
    }

    buffer.write('    return ${route.routeClassName}(');
    final routeConstructorArgs = <String>[];
    for (final p in route.params) {
      if (p.isNamed) {
        if (!p.isRequired && p.defaultValueCode != null) {
          routeConstructorArgs.add(
            '${p.name}: (${p.name} ?? ${p.defaultValueCode})',
          );
        } else {
          routeConstructorArgs.add('${p.name}: ${p.name}');
        }
      } else {
        if (!p.isRequired && p.defaultValueCode != null) {
          routeConstructorArgs.add('(${p.name} ?? ${p.defaultValueCode})');
        } else {
          routeConstructorArgs.add(p.name);
        }
      }
    }

    if (routeConstructorArgs.isEmpty) {
      // No parameters, single line
      buffer.writeln(');');
    } else {
      // Has parameters, multi-line format
      buffer.writeln();
      buffer.writeln('      ${routeConstructorArgs.join(',\n      ')}');
      buffer.writeln('    );');
    }
    buffer.writeln('  }');

    buffer.writeln();

    // Static routeInfo (inline TeleportRouteInfo)
    buffer.writeln('  /// The route info for this route.');
    buffer.writeln(
        '  static final TeleportRouteInfo routeInfo = TeleportRouteInfo(');
    buffer.writeln("    path: '${route.path}',");

    // Add route prefix for identification in Observer
    buffer.writeln(
      "    name: '$_kRoutePrefix${route.routeClassName}',",
    );
    buffer.writeln('    isInitial: ${route.isInitial},');

    if (route.onExit != null) {
      buffer.writeln(
          '    onExit: (context, data) => ${route.onExit}().onExit(context, $routeClassName.fromData(data)),');
    }

    if (route.fullscreenDialog) {
      buffer.writeln('    fullscreenDialog: true,');
    }
    if (!route.opaque) {
      buffer.writeln('    opaque: false,');
    }
    if (route.barrierDismissible) {
      buffer.writeln('    barrierDismissible: true,');
    }
    if (route.barrierColor != null) {
      buffer.writeln('    barrierColor: Color(${route.barrierColor}),');
    }
    if (route.barrierLabel != null) {
      buffer.writeln("    barrierLabel: '${route.barrierLabel}',");
    }
    if (!route.maintainState) {
      buffer.writeln('    maintainState: false,');
    }
    if (route.pageType != null) {
      buffer.writeln('    type: ${route.pageType},');
    }
    buffer.write('    params: [');
    if (route.params.isEmpty) {
      buffer.writeln('],');
    } else {
      buffer.writeln();
      for (final param in route.params) {
        buffer.writeln('      TeleportParamInfo(');
        buffer.writeln("        name: '${param.name}',");
        buffer.writeln("        urlName: '${param.urlName}',");
        buffer.writeln("        type: '${param.type}',");
        buffer.writeln('        isRequired: ${param.isRequired},');
        buffer.writeln("        source: '${param.source}',");
        buffer.writeln('      ),');
      }
      buffer.writeln('    ],');
    }
    if (route.redirect != null) {
      buffer.writeln(
        '    redirect: (context, data) async {',
      );
      buffer.writeln('      final route = $routeClassName.fromData(data);');
      if (route.redirect!.isClass) {
        buffer.writeln(
          '      return ${route.redirect!.name}().handle(context, route);',
        );
      } else {
        buffer.writeln('      return ${route.redirect!.name}(context, route);');
      }
      buffer.writeln('    },');
    }
    buffer.writeln('    builder: (settings) {');
    // Generate parameter extraction
    for (final param in route.params) {
      buffer.writeln(generateParamExtraction(param));
    }
    // Generate constructor call
    buffer.write('      return ${route.className}(');
    final constructorArgs = <String>[];
    for (final p in route.params) {
      if (p.isNamed) {
        if (!p.isRequired && p.defaultValueCode != null) {
          constructorArgs.add(
            '${p.name}: (${p.name} ?? ${p.defaultValueCode})',
          );
        } else {
          constructorArgs.add('${p.name}: ${p.name}');
        }
      } else {
        if (!p.isRequired && p.defaultValueCode != null) {
          constructorArgs.add('(${p.name} ?? ${p.defaultValueCode})');
        } else {
          constructorArgs.add(p.name);
        }
      }
    }
    buffer.writeln('${constructorArgs.join(', ')});');
    buffer.writeln('    },');

    // Add transition parameters if specified
    if (route.transitionType != null) {
      buffer.writeln('    transition: const ${route.transitionType}(),');
      buffer.writeln(
        '    transitionDuration: const Duration(microseconds: ${route.transitionDuration.inMicroseconds}),',
      );
      buffer.writeln(
        '    reverseTransitionDuration: const Duration(microseconds: ${route.reverseTransitionDuration.inMicroseconds}),',
      );
    }
    if (route.pageBuilder != null) {
      buffer.writeln('    pageBuilder: ${route.pageBuilder!.name}(),');
    }

    buffer.writeln('  );');
    buffer.writeln();

    // Build path method
    buffer.writeln('  @override');
    buffer.writeln('  String get fullPath {');
    buffer.writeln("    var p = '${route.path}';");

    // Replace path parameters
    final pathParams = route.params.where((p) => p.source == 'path');
    for (final param in pathParams) {
      buffer.writeln(
        "    p = p.replaceAll(':${param.urlName}', ${param.name}.toString());",
      );
    }

    // Build query parameters
    final queryParams = route.params.where(
      (p) =>
          p.source == 'query' ||
          (p.source == 'auto' && !isComplexType(p.baseType)),
    );
    if (queryParams.isNotEmpty) {
      buffer.writeln('    final queryParts = <String>[];');
      for (final param in queryParams) {
        if (param.isNullable) {
          buffer.writeln(
            "    if (${param.name} != null) queryParts.add('${param.urlName}=\${Uri.encodeComponent(${param.name}.toString())}');",
          );
        } else {
          buffer.writeln(
            "    queryParts.add('${param.urlName}=\${Uri.encodeComponent(${param.name}.toString())}');",
          );
        }
      }
      buffer.writeln(
        "    if (queryParts.isNotEmpty) p = '\$p?\${queryParts.join('&')}';",
      );
    }

    buffer.writeln('    return p;');
    buffer.writeln('  }');
    buffer.writeln();

    // Path pattern getter
    buffer.writeln('  @override');
    buffer.writeln("  String get pathPattern => '${route.originalPath}';");
    buffer.writeln();

    // Extra data getter
    final extraParams = route.params.where((p) => p.source == 'extra');
    if (extraParams.isNotEmpty) {
      buffer.writeln('  @override');
      buffer.writeln('  Map<String, dynamic> get extra => {');
      for (final param in extraParams) {
        buffer.writeln("    '${param.urlName}': ${param.name},");
      }
      buffer.writeln('  };');
      buffer.writeln();
    }

    buffer.writeln('}');
    buffer.writeln();

    return buffer.toString();
  }

  /// Gets an example value for a parameter type.
  String getExampleValue(ParamData param) {
    switch (param.baseType) {
      case 'int':
        return '123';
      case 'double':
        return '1.0';
      case 'bool':
        return 'true';
      case 'String':
        return "'value'";
      default:
        return 'value';
    }
  }

  /// Generates extraction code for a single parameter.
  String generateParamExtraction(ParamData p) {
    final name = p.name;
    final urlName = p.urlName;
    final isRequired = p.isRequired;

    // Determine the source access method for string-based parameters
    String stringSourceAccess;
    switch (p.source) {
      case 'path':
        stringSourceAccess = "settings.pathParams['$urlName']";
        break;
      case 'query':
        stringSourceAccess = "settings.queryParams['$urlName']";
        break;
      default:
        // Default (extra) fallback
        stringSourceAccess =
            "settings.pathParams['$urlName'] ?? settings.queryParams['$urlName']";
    }

    // Identify if we should check settings.extra for this parameter
    // User logic: checkExtra if not path and not query
    final checkExtra = p.source != 'path' && p.source != 'query';

    // Helper to generate the extra check block
    String generateExtraCheck(String type) {
      if (!checkExtra) return '';
      return '''
      final extraValue = settings.extra?['$urlName'];
      if (extraValue is $type) {
        return extraValue;
      }
''';
    }

    // Generates the parsing logic closure
    String generateParsingLogic(
      String type,
      String parseMethod, {
      bool isBool = false,
    }) {
      final extraCheck = generateExtraCheck(type);
      return '''      final $name = (() {
${extraCheck.isNotEmpty ? '$extraCheck\n' : ''}        final raw = $stringSourceAccess;
        if (raw == null) {
          ${isRequired ? "throw ArgumentError('Missing required parameter: $name');" : "return null;"}
        }
        ${isBool ? '''final lower = raw.toLowerCase();
        if (lower == 'true' || lower == '1' || lower == 'yes') return true;
        if (lower == 'false' || lower == '0' || lower == 'no') return false;
        ${isRequired ? "throw ArgumentError('Invalid bool value for: $name');" : "return null;"}''' : '''final parsed = $parseMethod(raw);
        if (parsed == null) {
          ${isRequired ? "throw ArgumentError('Invalid $type value for: $name');" : "return null;"}
        }
        return parsed;'''}
      })();''';
    }

    // Generate type-specific extraction
    switch (p.baseType) {
      case 'int':
        return generateParsingLogic('int', 'int.tryParse');

      case 'double':
        return generateParsingLogic('double', 'double.tryParse');

      case 'bool':
        return generateParsingLogic('bool', '', isBool: true);

      case 'num':
        return generateParsingLogic('num', 'num.tryParse');

      case 'String':
      default:
        // Complex types strictly use extra extraction (with check)
        if (isComplexType(p.baseType)) {
          return generateExtraExtraction(p);
        }

        // String case: for extra source, settings[key] already handles all
        // lookups internally, so no fallback needed.
        if (checkExtra) {
          return '''      final $name = (() {
        // Try getting from extra/map first via operator []
        final val = settings['$urlName'];
        if (val is String) {
          return val;
        }
        ${isRequired ? "throw ArgumentError('Missing required parameter: $name');" : "return null;"}
      })();''';
        }

        // Path/Query String case (source is 'path' or 'query')
        if (isRequired) {
          return '''      final $name = ($stringSourceAccess ??
          (throw ArgumentError('Missing required parameter: $name')));''';
        } else {
          return '''      final $name = $stringSourceAccess;''';
        }
    }
  }

  /// Generates extraction for complex types from extra.
  String generateExtraExtraction(ParamData p) {
    final name = p.name;
    final urlName = p.urlName;
    final type = p.type;
    final isRequired = p.isRequired;

    return '''      final $name = (() {
        // Try getting from map first
        final val = settings['$urlName'];
        if (val is $type) return val;

        // Try casting the whole extra object
        final asType = settings.getExtraAs<$type>();
        if (asType != null) return asType;

        ${isRequired ? "throw ArgumentError('Missing required parameter: $name');" : "return null;"}
      })();''';
  }

  /// Gets the base type without nullability suffix.
  String getBaseType(String type) {
    if (type.endsWith('?')) {
      return type.substring(0, type.length - 1);
    }
    return type;
  }

  /// Checks if a type is complex (not a primitive).
  bool isComplexType(String type) {
    const primitives = ['String', 'int', 'double', 'bool', 'num'];
    return !primitives.contains(type);
  }
}
