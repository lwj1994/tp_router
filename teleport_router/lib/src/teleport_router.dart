import 'dart:async';
import 'package:flutter/widgets.dart';
import 'package:flutter/scheduler.dart';
import 'package:go_router/go_router.dart';
import 'package:teleport_router_annotation/teleport_router_annotation.dart';
import 'navigator_key_registry.dart';
import 'navi_key.dart';
import 'route.dart';
import 'route_observer.dart';
import 'teleport_route_info.dart';
import 'page_factory.dart';
import 'log_util.dart';

/// Main router class that wraps go_router with teleport_router routes.
///
/// This class provides a simple interface to configure and use
/// the router with automatically generated routes.
///
/// **Usage Note**:
/// This router must be initialized **early** in your application lifecycle (e.g. in `main()`),
/// before any navigation actions are performed.
///
/// Example:
/// ```dart
/// void main() {
///   final router = TeleportRouter(
///     routes: [...], // Generated routes
///   );
///   runApp(MaterialApp.router(
///     routerConfig: router.routerConfig,
///   ));
/// }
/// ```
class TeleportRouter {
  /// The underlying go_router instance.
  final GoRouter _goRouter;

  /// The list of registered routes.
  final List<TeleportRouteBase> _routes;

  static TeleportRouter? _instance;

  /// Get the global router instance.
  ///
  /// This is available after the first call to the factory constructor.
  static TeleportRouter get instance {
    if (_instance == null) {
      throw FlutterError(
        'TeleportRouter has not been initialized. '
        'Ensure you create a TeleportRouter instance before accessing it.',
      );
    }
    return _instance!;
  }

  /// Check if TeleportRouter has been initialized.
  static bool get isInitialized => _instance != null;

  TeleportNavKey get navigatorKey => TeleportNavigatorKeyRegistry.rootKey;

  /// Creates a [TeleportRouter] from a list of [TeleportRouteBase].
  ///
  /// [routes] should be generated by build_runner or manually assembled.
  ///
  /// [errorBuilder] A custom error page builder.
  ///
  /// [redirect] A global redirection function. This is called for every navigation.
  /// Return a path string to redirect, or null to continue.
  ///
  /// [refreshListenable] A [Listenable] that triggers a refresh of the router
  /// (e.g. for authentication state changes).
  ///
  /// [redirectLimit] The maximum number of redirects allowed during a single
  /// navigation. Defaults to 5.
  ///
  /// [routerNeglect] Whether to ignore the browser history tracking.
  /// Defaults to false.
  ///
  /// [initialRoute] The initial route of the router. If not provided,
  /// it usually defaults to auto-detected initial route or `/`.
  ///
  /// [overridePlatformDefaultLocation] Whether to override the platform default
  /// initial route. Defaults to false.
  ///
  /// [initialExtra] The extra data to pass to the initial route.
  ///
  /// [observers] A list of [NavigatorObserver]s to monitor navigation events.
  /// Note: [TeleportRouteObserver] is automatically added for stack manipulation support.
  ///
  /// [debugLogDiagnostics] Whether to log diagnostic info to the console.
  /// Defaults to false.
  ///
  /// [enableLogging] Whether to enable TeleportRouter debug logging.
  /// When enabled, logs navigation events, route matching, and parameter extraction.
  /// Defaults to false. Only works in debug mode.
  ///
  /// [navigatorKey] A global key for the root navigator.
  ///
  /// [restorationScopeId] An identifier for state restoration.
  ///
  /// [requestFocus] Whether the router should request focus associated with
  /// the current route. Defaults to true.
  ///
  /// [defaultTransition] Global default page transition builder.
  /// Used when a route does not specify its own transition.
  ///
  /// [defaultTransitionDuration] Global default transition duration.
  ///
  /// [defaultReverseTransitionDuration] Global default reverse transition duration.
  factory TeleportRouter({
    required List<TeleportRouteBase> routes,
    Widget Function(BuildContext, TeleportRouteData)? errorBuilder,
    FutureOr<TeleportRouteData?> Function(
            BuildContext context, TeleportRouteData state)?
        redirect,
    Listenable? refreshListenable,
    int redirectLimit = 5,
    bool routerNeglect = false,
    String? initialRoute,
    bool overridePlatformDefaultLocation = false,
    Object? initialExtra,
    TeleportRouterConfig? config,
    List<NavigatorObserver>? observers,
    bool debugLogDiagnostics = false,
    bool enableLogging = false,
    TeleportNavKey? navigatorKey,
    String? restorationScopeId,
    bool requestFocus = true,
    TeleportTransitionsBuilder? defaultTransition,
    Duration? defaultTransitionDuration,
    Duration? defaultReverseTransitionDuration,
    TeleportPageType? defaultPageType,
    TeleportPageFactory? defaultPageBuilder,
  }) {
    // Initialize logging
    LogUtil.setEnabled(enableLogging);

    LogUtil.section('TeleportRouter Initialization');
    LogUtil.info('Registering ${routes.length} routes');

    // Use the provided key or fall back to the global root key
    if (navigatorKey != null) {
      TeleportNavigatorKeyRegistry.rootKey = navigatorKey;
      LogUtil.debug('Using custom navigator key: ${navigatorKey.key}');
    }
    // Determine initial route logic
    // If initialRoute is provided by user, use it.
    // Otherwise, try to auto-detect from routes.
    String? startLoc = initialRoute;

    if (startLoc == null) {
      LogUtil.debug('Auto-detecting initial route...');
      for (final route in routes) {
        final loc = _findInitialPath(route);
        if (loc != null) {
          startLoc = loc;
          LogUtil.info('Found initial route: $startLoc');
          break;
        }
      }

      // Default to '/' if no initial route found, or the first route's path if available
      if (startLoc == null && routes.isNotEmpty) {
        final first = routes.first;
        if (first is TeleportRouteInfo) {
          startLoc = first.path;
        }
      }
      startLoc ??= '/';
      if (initialRoute == null) {
        LogUtil.info('Using default initial route: $startLoc');
      }
    } else {
      LogUtil.info('Initial route set to: $startLoc');
    }

    // Convert TeleportRouteBase to GoRoute/ShellRoute
    // Use provided config or construct from parameters
    final effectiveConfig = config ??
        TeleportRouterConfig(
          defaultTransition: defaultTransition,
          defaultTransitionDuration: defaultTransitionDuration,
          defaultReverseTransitionDuration: defaultReverseTransitionDuration,
          defaultPageType: defaultPageType,
          defaultPageBuilder: defaultPageBuilder,
        );

    final goRoutes =
        routes.map((r) => r.toGoRoute(config: effectiveConfig)).toList();

    // Automatically inject TeleportRouteObserver for stack manipulation support
    final allObservers = [
      TeleportNavigatorKeyRegistry.rootKey.observer,
      ...?observers, // User-provided observers come after
    ];

    final goRouter = GoRouter(
      routes: goRoutes,
      initialLocation: startLoc,
      initialExtra: initialExtra,
      errorBuilder: errorBuilder != null
          ? (context, state) => errorBuilder(context, GoRouterStateData(state))
          : null,
      redirect: (context, state) async {
        if (redirect != null) {
          final target = await redirect(context, GoRouterStateData(state));
          return target?.fullPath;
        }
        return null;
      },
      refreshListenable: refreshListenable,
      redirectLimit: redirectLimit,
      routerNeglect: routerNeglect,
      overridePlatformDefaultLocation: overridePlatformDefaultLocation,
      observers:
          allObservers, // ‚Üê Use combined observers with TeleportRouteObserver
      debugLogDiagnostics: debugLogDiagnostics,
      navigatorKey: TeleportNavigatorKeyRegistry.rootKey.globalKey,
      restorationScopeId: restorationScopeId,
      requestFocus: requestFocus,
    );

    _instance = TeleportRouter._(goRouter, routes);
    return _instance!;
  }

  static String? _findInitialPath(TeleportRouteBase route) {
    if (route is TeleportRouteInfo) {
      if (route.isInitial) return route.path;
    } else if (route is TeleportShellRouteInfo) {
      for (final child in route.routes) {
        final path = _findInitialPath(child);
        if (path != null) return path;
      }
    } else if (route is TeleportStatefulShellRouteInfo) {
      for (final branch in route.branches) {
        for (final child in branch) {
          final path = _findInitialPath(child);
          if (path != null) return path;
        }
      }
    }
    return null;
  }

  TeleportRouter._(this._goRouter, this._routes);

  /// Get the router configuration for MaterialApp.router().
  RouterConfig<Object> get routerConfig => _goRouter;

  /// Get the list of registered routes.
  List<TeleportRouteBase> get routes => List.unmodifiable(_routes);

  /// Get the route observer for stack manipulation.
  ///
  /// This is used internally by delete() method.
  TeleportRouteObserver get routeObserver =>
      TeleportNavigatorKeyRegistry.rootKey.observer;

  /// Navigate to a route.
  ///
  /// This is the unified navigation method for all routing operations.
  ///
  /// - [route]: The route to navigate to. Use generated route classes or
  ///   [TeleportRouteData.fromPath] for dynamic paths.
  /// - [isReplace]: If true, replaces the current route instead of pushing.
  /// - [isClearHistory]: If true, clears the navigation stack (like `go`).
  ///

  /// Example:
  /// ```dart
  /// // Push a new route
  /// router.teleport(HomeRoute());
  ///
  /// // Replace current route
  /// router.teleport(SettingsRoute(), isReplace: true);
  ///
  /// // Clear history and go to route
  /// router.teleport(LoginRoute(), isClearHistory: true);
  ///
  /// // Using path directly
  /// router.teleport(TeleportRouteData.fromPath('/user/123'));
  /// ```
  Future<T?> teleport<T extends Object?>(
    TeleportRouteData route, {
    bool isReplace = false,
    bool isClearHistory = false,
  }) {
    // Log navigation
    final action = isClearHistory
        ? 'go (clear history)'
        : isReplace
            ? 'replace'
            : 'push';
    LogUtil.navigation('$action -> ${route.fullPath}');
    if (route.routeName != null) {
      LogUtil.route('Route name: ${route.routeName}');
    }
    if (route.pathParams.isNotEmpty) {
      LogUtil.params('Path params: ${route.pathParams}');
    }
    if (route.queryParams.isNotEmpty) {
      LogUtil.params('Query params: ${route.queryParams}');
    }
    if (route.extra != null) {
      // Try to format extra data in a readable way
      try {
        if (route.extra is Map) {
          LogUtil.params('Extra data: ${route.extra}');
        } else if (route.extra is List) {
          LogUtil.params('Extra data (list): ${route.extra}');
        } else {
          LogUtil.params(
              'Extra data (${route.extra.runtimeType}): ${route.extra}');
        }
      } catch (e) {
        LogUtil.params('Extra data: ${route.extra.runtimeType}');
      }
    }

    // Determine which GoRouter instance to use
    final targetRouter = _goRouter;

    if (isClearHistory) {
      targetRouter.go(route.fullPath, extra: route.extra);
      return Future.value(null);
    } else if (isReplace) {
      return targetRouter.pushReplacement<T>(route.fullPath,
          extra: route.extra);
    } else {
      return targetRouter.push<T>(route.fullPath, extra: route.extra);
    }
  }

  /// Pop the current route from the navigation stack.
  void pop<T extends Object?>({
    T? result,
  }) {
    if (canPop) {
      if (result != null) {
        // Format result value for logging
        try {
          if (result is Map) {
            LogUtil.navigation('pop with result: $result');
          } else if (result is List) {
            LogUtil.navigation('pop with result (list): $result');
          } else if (result is String || result is num || result is bool) {
            LogUtil.navigation(
                'pop with result (${result.runtimeType}): $result');
          } else {
            LogUtil.navigation(
                'pop with result (${result.runtimeType}): $result');
          }
        } catch (e) {
          LogUtil.navigation('pop with result: ${result.runtimeType}');
        }
      } else {
        LogUtil.navigation('pop');
      }
      _goRouter.pop<T>(result);
    } else {
      LogUtil.warning('Cannot pop: already at root route');
    }
  }

  /// Check if can pop the current route.
  bool get canPop => _goRouter.canPop();

  /// Get the current route data.
  TeleportRouteData currentRoute(
      {TeleportNavKey? navigatorKey, BuildContext? context}) {
    if (context != null) {
      return context.teleportRouteData;
    }

    if (navigatorKey != null) {
      final list = navigatorKey.observer.allRouteData;
      if (list.isNotEmpty) {
        return list.values.last;
      }
    }
    final GoRouterDelegate currentDelegate = _goRouter.routerDelegate;
    return RouteMatchListRouteData(currentDelegate);
  }

  /// Pop routes until the predicate is satisfied.
  ///
  /// The [predicate] callback is called for each route on the stack (from top to bottom).
  ///
  /// - [route]: The raw Flutter Route instance.
  /// - [data]: The associated [TeleportRouteData] if the route is managed by teleport_router.
  ///         If the route is not managed by teleport_router (e.g. standard Dialog), `data` will be null.
  ///
  /// Example:
  /// ```dart
  /// // Pop until we find the Home route
  /// router.popUntil((route, data) => data?.routeName == 'Home');
  /// ```
  void popUntil(
    bool Function(Route<dynamic> route, TeleportRouteData? data) predicate, {
    TeleportNavKey? navigatorKey,
    BuildContext? context,
  }) {
    final nav = context != null
        ? Navigator.of(context)
        : _getNavigator(navigatorKey: navigatorKey);
    final observer = _findObserverInNavigator(nav);

    // Iteratively check the top route and pop if predicate is not met
    while (observer.allRoutes.isNotEmpty) {
      final topRoute = observer.allRoutes.last;
      final data = observer.getRouteData(topRoute);

      if (predicate(topRoute, data)) {
        return; // Predicate satisfied, stop popping
      }

      if (topRoute.isFirst) {
        return; // Reached the first route, stop popping to avoid emptying stack
      }

      pop();
    }
  }

  /// Pop until the first route in the stack.
  void popToInitial({
    TeleportNavKey? navigatorKey,
    BuildContext? context,
  }) {
    popUntil((route, _) => route.isFirst,
        navigatorKey: navigatorKey, context: context);
  }

  /// Pop until the specified route is found.
  ///
  /// Matches by [TeleportRouteData.routeName] and [TeleportRouteData.fullPath].
  void popTo(
    TeleportRouteData route, {
    TeleportNavKey? navigatorKey,
    BuildContext? context,
  }) {
    popUntil((r, data) => data == route,
        navigatorKey: navigatorKey, context: context);
  }

  /// Remove a route from the navigation stack.
  bool removeRoute(
    TeleportRouteData route, {
    TeleportNavKey? navigatorKey,
  }) {
    return removeWhere(
          (data) =>
              data.routeName == route.routeName &&
              data.fullPath == route.fullPath,
          navigatorKey: navigatorKey,
        ) >
        0;
  }

  /// Remove all routes that match the given predicate.
  int removeWhere(
    bool Function(TeleportRouteData data) predicate, {
    TeleportNavKey? navigatorKey,
  }) {
    final observer = _findObserverInNavigator(_getNavigator(
      navigatorKey: navigatorKey,
    ));

    final routesToRemove = <Route>[];
    for (final route in observer.allRoutes) {
      final data = observer.getRouteData(route);
      if (data != null && predicate(data)) {
        routesToRemove.add(route);
      }
    }

    SchedulerBinding.instance.addPostFrameCallback((_) {
      for (final route in routesToRemove) {
        if (route.isCurrent) {
          // If current, just pop
          pop();
        } else {
          // If not current, mark for removal so it gets popped when revealed
          observer.markRouteForRemoval(route);
        }
      }
    });

    return routesToRemove.length;
  }

  /// Get the route observer for tracking navigation stack.
  TeleportRouteObserver getObserver({
    TeleportNavKey? navigatorKey,
    BuildContext? context,
  }) {
    if (context != null) {
      return _findObserverInNavigator(_getNavigator(
        context: context,
      ));
    }
    return (navigatorKey ?? TeleportNavigatorKeyRegistry.rootKey).observer;
  }

  /// Internal helper to get NavigatorState.
  ///
  /// Logic:
  /// 1. If navigatorKey is provided and found, use it.
  /// 2. Otherwise (navigatorKey null/not found), use root.
  NavigatorState _getNavigator(
      {TeleportNavKey? navigatorKey, BuildContext? context}) {
    if (context != null) return Navigator.of(context);
    // Try navigatorKey first
    if (navigatorKey != null) {
      final key = navigatorKey.globalKey;
      if (key.currentState != null) return key.currentState!;
      throw FlutterError(
        'Navigator for $navigatorKey is not mounted yet. '
        'Ensure the Navigator widget associated with this key is in the widget tree.',
      );
    }
    // Fallback to root
    return TeleportNavigatorKeyRegistry.rootKey.globalKey.currentState!;
  }

  TeleportRouteObserver _findObserverInNavigator(NavigatorState navigator) {
    final observer = _searchObservers(navigator.widget.observers);
    if (observer != null) return observer;
    throw FlutterError(
      'TeleportRouteObserver not found in Navigator. '
      'This is required for teleport_router to function properly. '
      'Ensure you are using TeleportRouter or manually adding TeleportRouteObserver to your Navigator.',
    );
  }

  TeleportRouteObserver? _searchObservers(List<NavigatorObserver> observers) {
    for (final observer in observers) {
      if (observer is TeleportRouteObserver) return observer;
      try {
        final dynamic dynamicObserver = observer;
        final children = dynamicObserver.observers;
        if (children is List<NavigatorObserver>) {
          final found = _searchObservers(children);
          if (found != null) return found;
        }
      } catch (_) {}
    }
    return null;
  }

  /// Dispose the router.
  void dispose() {
    _goRouter.dispose();
  }
}
